# 1.7.3 Vue3 响应式系统 API

## 1.reactive

>reactive 是 vue3 中对数据进行劫持的核心，主要是利用了 Proxy 进行劫持，  
相比于 Object.defineproperty 能够劫持的类型和范围都更好，  
再也不用像 vue2 中那样对数组进行类似 hack 方式的劫持了。  

>接收一个普通对象然后返回该普通对象的响应式代理。等同于 2.x 的 Vue.observable()

>源码中 vue3 是怎么劫持。首先看看这个对象是是不是 __v_isReadonly 只读的，  
如果是，直接返回，否者调用 createReactiveObject 进行创建

```

import { reactive, watchEffect } from 'vue'

// state 现在是一个响应式的状态
const state = reactive({
  count: 0,
})

watchEffect(() => {
  document.body.innerHTML = `count is ${state.count}`
})

// watchEffect 应该接收一个应用预期副作用 (这里即设置 innerHTML) 的函数。
它会立即执行该函数，并将该执行过程中用到的所有响应式状态的 property 作为依赖进行追踪
```

>响应式转换是“深层的”：会影响对象内部所有嵌套的属性。  
基于 ES2015 的 Proxy 实现，返回的代理对象不等于原始对象。

>建议仅使用代理对象而避免依赖原始对象。

- 类型定义

```
function reactive<T extends object>(raw: T): T
```

## 2.ref

>接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性 .value。

```
import { ref } from 'vue'
const count = ref(0)
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```

>如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换。

- 模板中访问

```
当 ref 作为渲染上下文的属性返回（即在setup() 返回的对象中）并在模板中使用时，它会自动解套，**无需在模板内额外书写 .value：**

<template>
  <div>{{ count }}</div>
</template>

<script>
  export default {
    setup() {
      return {
        count: ref(0),
      }
    },
  }
</script>
```

- 作为响应式对象的属性访问

>当 ref 作为 reactive 对象的 property 被访问或修改时，也将自动解套 value 值，其行为类似普通属性：

```
import { reactive, ref } from 'vue'
const count = ref(0)
const state = reactive({
  count,
})

console.log(state.count) // 0

state.count = 1
console.log(count.value) // 1
```

>注意:如果将一个新的 ref 分配给现有的 ref， 将替换旧的 ref：

```
const otherCount = ref(2)

state.count = otherCount
console.log(state.count) // 2
console.log(count.value) // 1
```

>注意:当嵌套在 reactive Object 中时，ref 才会解套。  
从 Array 或者 Map 等原生集合类中访问 ref 时，不会自动解套：

```
const arr = reactive([ref(0)])
// 这里需要 .value
console.log(arr[0].value)

const map = reactive(new Map([['foo', ref(0)]]))
// 这里需要 .value
console.log(map.get('foo').value)
```



## 3.computed

>传入一个 getter 函数，返回一个默认不可手动修改的 ref 对象

```
import { computed, ref } from 'vue'
const count = ref(1)
const plusOne = computed(() => count.value + 1)

console.log(plusOne.value) // 2

plusOne.value++ // 错误！
```

>或者传入一个拥有 get 和 set 函数的对象，创建一个可手动修改的计算状态。

```
const count = ref(1)
const plusOne = computed({
  get: () => count.value + 1,
  set: (val) => {
    count.value = val - 1
  },
})

plusOne.value = 1
console.log(count.value) // 0
```
>类型定义

```
// 只读的
function computed<T>(getter: () => T): Readonly<Ref<Readonly<T>>>

// 可更改的
function computed<T>(options: {
  get: () => T
  set: (value: T) => void
}): Ref<T>
```

## 4.readonly

>传入一个对象（响应式或普通）或 ref，返回一个原始对象的**只读**代理。  
一个只读的代理是“深层的”，**对象内部任何嵌套的属性**也都是**只读的**

```
import { reactive, readonly } from 'vue'
const original = reactive({ count: 0 })

const copy = readonly(original)

watchEffect(() => {
  // 依赖追踪
  console.log(copy.count)
})

// original 上的修改会触发 copy 上的侦听
original.count++

// 无法修改 copy 并会被警告
copy.count++ // warning!
```

## 5.watchEffect

>立即执行传入的一个函数，并响应式追踪其依赖，并在其依赖变更时重新运行该函数

```
import { ref, watchEffect } from 'vue'
const count = ref(0)

watchEffect(() => console.log(count.value))
// -> 打印出 0

setTimeout(() => {
  count.value++
  // -> 打印出 1
}, 100)
```

- 5.1停止侦听
>当 watchEffect 在组件的 setup() 函数或生命周期钩子被调用时， 侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。

在一些情况下，也可以显式调用返回值以停止侦听：

```
const stop = watchEffect(() => {
  /* ... */
})

// 之后
stop()
```
- 5.2清除副作用

>有时副作用函数会执行一些异步的副作用, 这些响应需要在其失效时清除（即完成之前状态已改变了）。  
所以侦听副作用传入的函数可以接收一个 **onInvalidate 函数作入参, 用来注册清理失效时的回调**。

当以下情况发生时，这个**失效回调**会被触发:

- 副作用即将重新执行时

- 侦听器被停止 (如果在 setup() 或 生命周期钩子函数中使用了 watchEffect, 则在卸载组件时)

```
watchEffect((onInvalidate) => {
  const token = performAsyncOperation(id.value)
  onInvalidate(() => {
    // id 改变时 或 停止侦听时
    // 取消之前的异步操作
    token.cancel()
  })
})
```

>之所以是通过传入一个函数去注册失效回调，而不是从回调返回它（如 React useEffect 中的方式），是因为返回值对于异步错误处理很重要。

在执行数据请求时，副作用函数往往是一个异步函数：

```
const data = ref(null)
watchEffect(async () => {
  data.value = await fetchData(props.id)
})
```
>异步函数都会隐式地返回一个 Promise，但是清理函数必须要在 Promise 被 resolve 之前被注册。  
另外，Vue 依赖这个返回的 Promise 来自动处理 Promise 链上的潜在错误


- 5.3副作用刷新时机

>Vue 的响应式系统会**缓存副作用函数，并异步地刷新它们**，这样可以**避免同一个 tick 中多个状态改变导致的不必要的重复调用**

> 组件的更新函数也是一个被侦听的副作用

```
<template>
  <div>{{ count }}</div>
</template>

<script>
  export default {
    setup() {
      const count = ref(0)

      watchEffect(() => {
        console.log(count.value)
      })

      return {
        count,
      }
    },
  }
</script>
```

在这个例子中：

- count 会在初始运行时同步打印出来
- 更改 count 时，将在组件更新后执行副作用。

>请注意，初始化运行是在组件 mounted 之前执行的。  
因此，如果你希望在编写副作用函数时访问 DOM（或模板 ref），请在 onMounted 钩子中进行：

```
onMounted(() => {
  watchEffect(() => {
    // 在这里可以访问到 DOM 或者 template refs
  })
})
```

>如果副作用需要同步或在组件更新之前重新运行，我们可以传递一个拥有 flush 属性的对象作为选项（默认为 'post'）：

```
// 同步运行
watchEffect(
  () => {
    /* ... */
  },
  {
    flush: 'sync',
  }
)

// 组件更新前执行
watchEffect(
  () => {
    /* ... */
  },
  {
    flush: 'pre',
  }
)
```



## 参考
- [响应式系统 API](https://vue-composition-api-rfc.netlify.app/zh/api.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F-api)
- [](https://hkc452.github.io/slamdunk-the-vue3/main/vue/reactivity/reactive.html)
