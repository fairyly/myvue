# 1.7.4 Vue3 响应式系统 API

## reactive

>reactive 是 vue3 中对数据进行劫持的核心，主要是利用了 Proxy 进行劫持，  
相比于 Object.defineproperty 能够劫持的类型和范围都更好，  
再也不用像 vue2 中那样对数组进行类似 hack 方式的劫持了。  

>接收一个普通对象然后返回该普通对象的响应式代理。等同于 2.x 的 Vue.observable()

>源码中 vue3 是怎么劫持。首先看看这个对象是是不是 __v_isReadonly 只读的，  
如果是，直接返回，否者调用 createReactiveObject 进行创建

```

import { reactive, watchEffect } from 'vue'

// state 现在是一个响应式的状态
const state = reactive({
  count: 0,
})

watchEffect(() => {
  document.body.innerHTML = `count is ${state.count}`
})

// watchEffect 应该接收一个应用预期副作用 (这里即设置 innerHTML) 的函数。
它会立即执行该函数，并将该执行过程中用到的所有响应式状态的 property 作为依赖进行追踪
```

>响应式转换是“深层的”：会影响对象内部所有嵌套的属性。  
基于 ES2015 的 Proxy 实现，返回的代理对象不等于原始对象。

>建议仅使用代理对象而避免依赖原始对象。

- 类型定义

```
function reactive<T extends object>(raw: T): T
```

## ref

>接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性 .value。

```
const count = ref(0)
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```

>如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换。

- 模板中访问

```
当 ref 作为渲染上下文的属性返回（即在setup() 返回的对象中）并在模板中使用时，它会自动解套，**无需在模板内额外书写 .value：**

<template>
  <div>{{ count }}</div>
</template>

<script>
  export default {
    setup() {
      return {
        count: ref(0),
      }
    },
  }
</script>
```

## 参考
- [响应式系统 API](https://vue-composition-api-rfc.netlify.app/zh/api.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F-api)
- [](https://hkc452.github.io/slamdunk-the-vue3/main/vue/reactivity/reactive.html)
