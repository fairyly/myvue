# webpack 项目优化
> webpack 版本不同，配置也会有一些地方不一样的

>
- 1.优化构建速度。在项目庞大时构建耗时可能会变的很长，每次等待构建的耗时加起来也会是个大数目。
  - 4-1 缩小文件搜索范围
  - 4-2 使用 DllPlugin
  - 4-3 使用 HappyPack
  - 4-4 使用 ParallelUglifyPlugin  
- 2.优化使用体验。通过自动化手段完成一些重复的工作，让我们专注于解决问题本身。
  - 4-5 使用自动刷新
  - 4-6 开启模块热替换

>
- 3.优化输出质量
  优化输出质量的目的是为了给用户呈现体验更好的网页，例如减少首屏加载时间、提升性能流畅度等。   
  这至关重要，因为在互联网行业竞争日益激烈的今天，这可能关系到你的产品的生死。
  优化输出质量本质是优化构建输出的要发布到线上的代码，分为以下几点：
  - 减少用户能感知到的加载时间，也就是首屏加载时间。
    - 4-7 区分环境
    - 4-8 压缩代码
    - 4-9 CDN 加速
    - 4-10 使用 Tree Shaking
    - 4-11 提取公共代码
    - 4-12 按需加载
  - 提升流畅度，也就是提升代码性能。
    - 4-13 使用 Prepack
    - 4-14 开启 Scope Hoisting
  - 优化的关键是找出问题所在，这样才能一针见血，
    - 4-15 输出分析 教你如何利用工具快速找出问题所在。
  - 4-16 优化总结 对以上的优化方法做一个总结

## 4-1 缩小文件搜索范围

- 4-1-1 优化 loader 配置
  ```
   为了尽可能少的让文件被 Loader 处理，可以通过 include 去命中只有哪些文件需要被处理。
  ```
- 4-1-2 优化 resolve.alias 配置
- 4-1-3 优化 resolve.extensions 配置

## 4-2 使用DllPlugin



## 4-3 使用 HappyPack


## 4-4 使用 ParallelUglifyPlugin
>用过 UglifyJS 的你一定会发现在构建用于开发环境的代码时很快就能完成，  
但在构建用于线上的代码时构建一直卡在一个时间点迟迟没有反应，其实卡住的这个时候就是在进行代码压缩。

>由于压缩 JavaScript 代码需要先把代码解析成用 Object 抽象表示的 AST 语法树，  
再去应用各种规则分析和处理 AST，导致这个过程计算量巨大，耗时非常多。

>为什么不把在4-3 使用 HappyPack中介绍过的多进程并行处理的思想也引入到代码压缩中呢？

>ParallelUglifyPlugin 就做了这个事情。   
当 Webpack 有多个 JavaScript 文件需要输出和压缩时，原本会使用 UglifyJS 去一个个挨着压缩再输出，   
但是 ParallelUglifyPlugin 则会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成，  
每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。   
所以 ParallelUglifyPlugin 能更快的完成对多个文件的压缩工作。

>使用 ParallelUglifyPlugin 也非常简单，把原来 Webpack 配置文件中内置的 UglifyJsPlugin 去掉后，再替换成 ParallelUglifyPlugin，

>**不过看到 GitHub 上说是支持并行的**，[uglifyjs-webpack-plugin/#parallel](https://github.com/webpack-contrib/uglifyjs-webpack-plugin/#parallel)


## 4-5 使用自动刷新


## 4-6 开启模块热替换


## 4-7 区分环境


## 4-8 压缩代码


## 4-9 CDN 加速


## 4-10 使用 Tree Shaking


## 4-11 提取公共代码


## 4-12 按需加载



## 4-13 使用 Prepack



## 4-14 开启 Scope Hoisting
  


## 4-15 输出分析
>为了更简单直观的分析输出结果，社区中出现了许多可视化的分析工具。  
这些工具以图形的方式把结果更加直观的展示出来，让你快速看到问题所在。 

>两种分析工具：
- 1.官方的可视化分析工具: [ Webpack Analyse: 在线 Web 应用](http://webpack.github.io/analyse/)
- 2.webpack-bundle-analyzer：

#### 4-15-1 生成 `stats.json`

在启动 Webpack 时带上以上两个参数，启动命令如下:
```
  webpack --profile --json > stats.json，
```
如果没有问题，你会发现项目中多出了一个 stats.json 文件。  
这个 stats.json 文件是给后面介绍的可视化分析工具使用的。

>可是我在 vue 项目中使用时出现了一个问题
```
web>webpack --profile --json > stats.json
No configuration file found and no output filename configured via CLI option.
A configuration file could be named 'webpack.config.js' in the current directory
.
Use --help to display the CLI options.
```
- 它的意思是，假如没有指定配置文件，会在当前目录寻找webpack.config.js 作为配置文件
- 解决： 使用 config 指定配置文件，
  ```
    webpack --config ./build/webpack.dev.conf.js --json > stats.json
  ```

>webpack --profile --json 会输出字符串形式的 JSON，  
> stats.json 是 UNIX/Linux 系统中的管道命令，  
含义是把 webpack --profile --json 输出的内容通过管道输出到 stats.json 文件中。


#### 4-15-2 官方的可视化分析工具: [ Webpack Analyse: 在线 Web 应用](http://webpack.github.io/analyse/)
>打开 Webpack Analyse 链接的网页后，你就会看到一个弹窗提示你上传 JSON 文件，  
也就是需要上传上面讲到的 stats.json 文件


#### 4-15-3 `webpack-bundle-analyzer`
>发现 vue-cli 2 版本中 webpack.prod.conf.js 里面有关于是否开启 webpack-bundle-analyzer 配置；
也就是说 `npm run build --report` 的时候，`BundleAnalyzerPlugin ` 能以可视化的方式展示打包结果;

  > 如果单独使用 webpack-bundle-analyzer：
  - 1.安装 webpack-bundle-analyzer 到全局，执行命令 npm i -g webpack-bundle-analyzer；
  - 2.按照上面提到的方法生成 stats.json 文件；
  - 3.在项目根目录中执行 webpack-bundle-analyzer 后，浏览器会打开对应网页看到以上效果


## 4-16 优化总结
>按照开发环境和线上环境为该项目配置了两份文件，下面是使用 `webpack4` 版本

- 侧重优化开发体验的配置文件 webpack.config.js：

```
const path = require('path');
const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');
const {AutoWebPlugin} = require('web-webpack-plugin');
const HappyPack = require('happypack');

// 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用
const autoWebPlugin = new AutoWebPlugin('./src/pages', {
  // HTML 模版文件所在的文件路径
  template: './template.html',
  // 提取出所有页面公共的代码
  commonsChunk: {
    // 提取出公共代码 Chunk 的名称
    name: 'common',
  },
});

module.exports = {
  // AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置，
  // autoWebPlugin.entry 方法可以获取到生成入口配置
  entry: autoWebPlugin.entry({
    // 这里可以加入你额外需要的 Chunk 入口
    base: './src/base.js',
  }),
  output: {
    filename: '[name].js',
  },
  resolve: {
    // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤
    // 其中 __dirname 表示当前工作目录，也就是项目根目录
    modules: [path.resolve(__dirname, 'node_modules')],
    // 针对 Npm 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件，使用 Tree Shaking 优化
    // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤
    mainFields: ['jsnext:main', 'main'],
  },
  module: {
    rules: [
      {
        // 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能
        test: /\.js$/,
        // 使用 HappyPack 加速构建
        use: ['happypack/loader?id=babel'],
        // 只对项目根目录下的 src 目录中的文件采用 babel-loader
        include: path.resolve(__dirname, 'src'),
      },
      {
        test: /\.js$/,
        use: ['happypack/loader?id=ui-component'],
        include: path.resolve(__dirname, 'src'),
      },
      {
        // 增加对 CSS 文件的支持
        test: /\.css$/,
        use: ['happypack/loader?id=css'],
      },
    ]
  },
  plugins: [
    autoWebPlugin,
    // 使用 HappyPack 加速构建
    new HappyPack({
      id: 'babel',
      // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启
      loaders: ['babel-loader?cacheDirectory'],
    }),
    new HappyPack({
      // UI 组件加载拆分
      id: 'ui-component',
      loaders: [{
        loader: 'ui-component-loader',
        options: {
          lib: 'antd',
          style: 'style/index.css',
          camel2: '-'
        }
      }],
    }),
    new HappyPack({
      id: 'css',
      // 如何处理 .css 文件，用法和 Loader 配置中一样
      loaders: ['style-loader', 'css-loader'],
    }),
    // 4-11提取公共代码
    new CommonsChunkPlugin({
      // 从 common 和 base 两个现成的 Chunk 中提取公共的部分
      chunks: ['common', 'base'],
      // 把公共的部分放到 base 中
      name: 'base'
    }),
  ],
  watchOptions: {
    // 4-5使用自动刷新：不监听的 node_modules 目录下的文件
    ignored: /node_modules/,
  }
};
```

- 侧重优化输出质量的配置文件 webpack-dist.config.js：

```
const path = require('path');
const DefinePlugin = require('webpack/lib/DefinePlugin');
const ModuleConcatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin');
const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const {AutoWebPlugin} = require('web-webpack-plugin');
const HappyPack = require('happypack');
const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');

// 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用
const autoWebPlugin = new AutoWebPlugin('./src/pages', {
  // HTML 模版文件所在的文件路径
  template: './template.html',
  // 提取出所有页面公共的代码
  commonsChunk: {
    // 提取出公共代码 Chunk 的名称
    name: 'common',
  },
  // 指定存放 CSS 文件的 CDN 目录 URL
  stylePublicPath: '//css.cdn.com/id/',
});

module.exports = {
  // AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置，
  // autoWebPlugin.entry 方法可以获取到生成入口配置
  entry: autoWebPlugin.entry({
    // 这里可以加入你额外需要的 Chunk 入口
    base: './src/base.js',
  }),
  output: {
    // 给输出的文件名称加上 Hash 值
    filename: '[name]_[chunkhash:8].js',
    path: path.resolve(__dirname, './dist'),
    // 指定存放 JavaScript 文件的 CDN 目录 URL
    publicPath: '//js.cdn.com/id/',
  },
  resolve: {
    // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤
    // 其中 __dirname 表示当前工作目录，也就是项目根目录
    modules: [path.resolve(__dirname, 'node_modules')],
    // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤
    mainFields: ['jsnext:main', 'main'],
  },
  module: {
    rules: [
      {
        // 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能
        test: /\.js$/,
        // 使用 HappyPack 加速构建
        use: ['happypack/loader?id=babel'],
        // 只对项目根目录下的 src 目录中的文件采用 babel-loader
        include: path.resolve(__dirname, 'src'),
      },
      {
        test: /\.js$/,
        use: ['happypack/loader?id=ui-component'],
        include: path.resolve(__dirname, 'src'),
      },
      {
        // 增加对 CSS 文件的支持
        test: /\.css$/,
        // 提取出 Chunk 中的 CSS 代码到单独的文件中
        use: ExtractTextPlugin.extract({
          use: ['happypack/loader?id=css'],
          // 指定存放 CSS 中导入的资源（例如图片）的 CDN 目录 URL
          publicPath: '//img.cdn.com/id/'
        }),
      },
    ]
  },
  plugins: [
    autoWebPlugin,
    // 4-14开启ScopeHoisting
    new ModuleConcatenationPlugin(),
    // 4-3使用HappyPack
    new HappyPack({
      // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件
      id: 'babel',
      // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启
      loaders: ['babel-loader?cacheDirectory'],
    }),
    new HappyPack({
      // UI 组件加载拆分
      id: 'ui-component',
      loaders: [{
        loader: 'ui-component-loader',
        options: {
          lib: 'antd',
          style: 'style/index.css',
          camel2: '-'
        }
      }],
    }),
    new HappyPack({
      id: 'css',
      // 如何处理 .css 文件，用法和 Loader 配置中一样
      // 通过 minimize 选项压缩 CSS 代码
      loaders: ['css-loader?minimize'],
    }),
    new ExtractTextPlugin({
      // 给输出的 CSS 文件名称加上 Hash 值
      filename: `[name]_[contenthash:8].css`,
    }),
    // 4-11提取公共代码
    new CommonsChunkPlugin({
      // 从 common 和 base 两个现成的 Chunk 中提取公共的部分
      chunks: ['common', 'base'],
      // 把公共的部分放到 base 中
      name: 'base'
    }),
    new DefinePlugin({
      // 定义 NODE_ENV 环境变量为 production 去除 react 代码中的开发时才需要的部分
      'process.env': {
        NODE_ENV: JSON.stringify('production')
      }
    }),
    // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码
    new ParallelUglifyPlugin({
      // 传递给 UglifyJS 的参数
      uglifyJS: {
        output: {
          // 最紧凑的输出
          beautify: false,
          // 删除所有的注释
          comments: false,
        },
        compress: {
          // 在UglifyJs删除没有用到的代码时不输出警告
          warnings: false,
          // 删除所有的 `console` 语句，可以兼容ie浏览器
          drop_console: true,
          // 内嵌定义了但是只用到一次的变量
          collapse_vars: true,
          // 提取出出现多次但是没有定义成变量去引用的静态值
          reduce_vars: true,
        }
      },
    }),
  ]
};
```


## 参考
- [深入浅出 webpack ](http://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-1%E7%BC%A9%E5%B0%8F%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%8C%83%E5%9B%B4.html)
